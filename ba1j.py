# -*- coding: utf-8 -*-
"""ba1j.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Qpwboq4g14ufUgJ_4gG0RUX3djQvg862

**Frequent Words with Mismatches and Reverse Complements Problem**

Find the most frequent k-mers (with mismatches and reverse complements) in a DNA string.

Given: A DNA string Text as well as integers k and d.

Return: All k-mers Pattern maximizing the sum Countd(Text, Pattern) + Countd(Text, Pattern) over all possible k-mers.
"""

def HammingDistance(p,q):
    n = len(p)
    counter = 0
    for i in range(0,n):
        if p[i] != q[i]:
            counter += 1
    return counter

def Neighbors(Pattern, d):
    
    if d == 0:
       return [Pattern]
    if len(Pattern) == 1:
        return ['A','C','G','T']

    neighborhood = []
    suffixNeighbors = Neighbors(Pattern[1:], d)

    for Text in suffixNeighbors:
        if HammingDistance(Pattern[1:], Text) < d:
            neighborhood.append('A'+Text)
            neighborhood.append('C'+Text)
            neighborhood.append('G'+Text)
            neighborhood.append('T'+Text)
        else:
            neighborhood.append(Pattern[0] + Text)
            
    return neighborhood

def NumberToSymbol(num):

    if num == 0:
        return "A"
    if num == 1:
        return "C"
    if num == 2:
        return "G"
    if num == 3:
        return "T"


def NumberToPattern(index,k):

    if k == 1:
        return NumberToSymbol(index)

    remainder = index % 4
    index = index // 4
    pattern = NumberToPattern(index,k-1) 
    return pattern + NumberToSymbol(remainder)

def SymbolToNumber(symbol):

    if symbol == "A":
        return 0
    elif symbol == "C":
        return 1
    elif symbol == "G":
        return 2
    elif symbol == "T":
        return 3


def PatternToNumber(Pattern):

    if Pattern == "":
        return 0

    symbol = Pattern[len(Pattern)-1]
    prefix = Pattern[0:len(Pattern)-1]
    return 4*PatternToNumber(prefix) + SymbolToNumber(symbol)

def Complement(p):
    if p == 'A':
        return 'T'
    if p == 'T':
        return 'A'
    if p == 'G':
        return 'C'
    if p == 'C':
        return 'G'

def ReverseComplement(Pattern):
    
    n = len(Pattern)
    rev_comp = ""
    
    for i in range(0, n):
        rev_comp = Complement(Pattern[i]) + rev_comp
                              
    return rev_comp

def FreqWordsWithMismatchesAndReverseComplement(text,k,d):
  FreqPatterns=[]
  count=[0]*pow(4,k)
  for i in range(0,len(text)-k+1):
    neighbors = Neighbors(text[i:i+k],d) 
    neighbors_rev_comp = Neighbors(ReverseComplement(text[i:i+k]),d)
    for neighbor in neighbors:
        index = PatternToNumber(neighbor)
        count[index] += 1
    for neighbor in neighbors_rev_comp:
        index = PatternToNumber(neighbor)
        count[index] += 1
  maxCount=max(count)
  for i in range(0,len(count)):
    if count[i] == maxCount:
            Pattern = NumberToPattern(i,k)
            FreqPatterns.append(Pattern)
  return FreqPatterns

text=""

print(FreqWordsWithMismatchesAndReverseComplement(text,5,3))