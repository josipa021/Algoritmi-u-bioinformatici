# -*- coding: utf-8 -*-
"""ba2d.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kiYacpUOAni_zp4sx7ZQ_s9-TqufeF7x

**Implement GreedyMotifSearch**

Given: Integers k and t, followed by a collection of strings Dna.

Return: A collection of strings BestMotifs resulting from running GreedyMotifSearch(Dna, k, t). If at any step you find more than one Profile-most probable k-mer in a given string, use the one occurring first.
"""

def Row(char):

    if char == 'A':
        return 0
    if char == 'C':
        return 1
    if char == 'G':
        return 2
    if char == 'T':
        return 3


def Probability(kmer, Profile):

    prob = 1
    for i in range(0,len(kmer)):

        char = kmer[i]
        row = Row(char)
        prob *= Profile[row][i]

    return prob

def ProfileMostProbable_kMer(Text, k, Profile):

    maximum = Probability(Text[0:k],Profile)
    most_probable = Text[0:k]
    
    for i in range(1,len(Text) - k + 1):

        if (Probability(Text[i:i+k],Profile) > maximum):

            maximum = Probability(Text[i:i+k],Profile)
            most_probable = Text[i:i+k]

    return most_probable

def MaxNmbrOfOccurencesOfLetterInColumn(Motifs,j):

    '''
    ovdje za svaki motiv gledam koje se slovo pojavljuje na j-tom mjestu
    (u j-tom stupcu) i brojim ponavljanja svakog slova. VraÄ‡am najveci
    broj pojavljivanja nekog slova
    '''
    countACGT = [0,0,0,0]
    for i in range(0,len(Motifs)):

        if(Motifs[i][j] == 'A'):
            countACGT[0] +=1
        elif(Motifs[i][j] == 'C'):
            countACGT[1] +=1
        elif(Motifs[i][j] == 'G'):
            countACGT[2] +=1
        elif(Motifs[i][j] == 'T'):
            countACGT[3] +=1

    return max(countACGT)

'''
score broji koliko se slova razlikuje od najcesceg slova u svakom stupcu i
zbraja rezultate po stupcima
'''
def Score(Motifs):

    score = 0;
    for i in range(0,len(Motifs[0])):

        score += (len(Motifs) - MaxNmbrOfOccurencesOfLetterInColumn(Motifs,i))

    return score

'''
Profile matricu formiram na nacin:
za svaki stupac razdijelim vjerojatnosti na sva slova
koja se pojavljuju u motivima na tom mjestu(stupcu)
'''
def FormProfile(strings):

    n = len(strings)
    k = len(strings[0])

    Profile = []

    for m in range (0,4):
        
        ProfileRow = [0]*k
        for i in range(0,k):
            for j in range(0,n):
                row = Row(strings[j][i])
                if m == row:
                    ProfileRow[i] += 1/n
                    
        Profile.append(ProfileRow)

    return Profile

def GreedyMotifSearch(k,t,Dna):

    BestMotifs = []
    
    for i in range(0,len(Dna)):
        BestMotifs.append(Dna[i][0:k])

    for i in range(0, len(Dna[0]) - k + 1):

        Motifs = []
        Motif1 = Dna[0][i:i+k]
        Motifs.append(Motif1)
        
        for j in range(1,t):

            Profile = FormProfile(Motifs)
            Motif_j = ProfileMostProbable_kMer(Dna[j], k, Profile)

            Motifs.append(Motif_j)

        if (Score(Motifs) < Score(BestMotifs)):
            BestMotifs = Motifs

    return BestMotifs

def Output(array):

    print ('\n'.join(array))

f=open('rosalind_ba2d.txt')
lines=f.readlines()

k = int(lines[0].strip('\n').split(' ')[0])
t = int(lines[0].strip('\n').split(' ')[1])
Dna = []

for i in range(1,len(lines)):
    Dna.append(lines[i].strip('\n'))

Output(GreedyMotifSearch(k,t,Dna))