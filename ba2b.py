# -*- coding: utf-8 -*-
"""ba2b.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jTkEp3kTlPEGIzMHDrdhmB6LE3xtZsX1

**Median String Problem**

Find a median string.

Given: An integer k and a collection of strings Dna.

Return: A k-mer Pattern that minimizes d(Pattern, Dna) over all k-mers Pattern. (If multiple answers exist, you may return any one.)
"""

def HammingDistance(p,q):
    
    n = len(p)
    counter = 0
    for i in range(0,n):
        if p[i] != q[i]:
            counter += 1
    return counter


def NumberToSymbol(num):

    if num == 0:
        return "A"
    if num == 1:
        return "C"
    if num == 2:
        return "G"
    if num == 3:
        return "T"


def NumberToPattern(index,k):

    if k == 1:
        return NumberToSymbol(index)

    remainder = index % 4
    index = index // 4
    pattern = NumberToPattern(index,k-1) 
    return pattern + NumberToSymbol(remainder)

def DistancePatternText(Pattern, Text):

    k = len(Pattern)
    minimum = HammingDistance(Pattern, Text[0:k])
    for i in range(1, len(Text) - k + 1):
        if(HammingDistance(Pattern, Text[i:i+k]) < minimum):
            minimum = HammingDistance(Pattern, Text[i:i+k])

    return minimum


def DistancePatternDna(Pattern, Dna):

    distance = 0
    for i in range(0,len(Dna)):
        distance += DistancePatternText(Pattern, Dna[i])

    return distance

def MedianString(k, Dna):

    median = NumberToPattern(0,k)
    minimum = DistancePatternDna(median,Dna)
    # provjeravam udaljenost svih mogucih k-mera od Dna i uzimam onaj s najmanjom
    for i in range(1, pow(4,k)):
        Pattern = NumberToPattern(i,k)
        if(DistancePatternDna(Pattern,Dna) < minimum):
            minimum = DistancePatternDna(Pattern,Dna)
            median = Pattern
    return median

f=open('rosalind_ba2b.txt')
lines=f.readlines()

k = int(lines[0].strip('\n'))
Dna = []

for i in range(1,len(lines)):
    Dna.append(lines[i].strip('\n'))

print(MedianString(k,Dna))